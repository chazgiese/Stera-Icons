#!/usr/bin/env node

/**
 * Generate TypeScript declarations for the icon library.
 * 
 * This script generates .d.ts files without using the TypeScript compiler,
 * which allows it to run with constant memory regardless of icon count.
 * 
 * Generated files:
 * - dist/types.d.ts - Core type definitions
 * - dist/IconBase.d.ts - IconBase component declaration
 * - dist/base.d.ts - Separate entry point for IconBase (advanced usage)
 * - dist/index.d.ts - Main entry re-exporting all icons
 */

import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const REACT_PACKAGE_DIR = join(__dirname, '..', 'packages', 'react');
const SRC_DIR = join(REACT_PACKAGE_DIR, 'src');
const DIST_DIR = join(REACT_PACKAGE_DIR, 'dist');

/**
 * Generate types.d.ts from src/types.ts
 */
function generateTypesDeclaration() {
  const typesContent = `import { SVGProps } from 'react';

export type IconWeight = 'regular' | 'bold' | 'fill';

export interface IconProps extends Omit<SVGProps<SVGSVGElement>, 'children'> {
  size?: number | string;
  color?: string;
  weight?: IconWeight;
  duotone?: boolean;
  'aria-label'?: string;
  'aria-hidden'?: boolean;
}

export interface IconMetadata {
  name: string;
  weight: 'regular' | 'bold' | 'fill';
  duotone: boolean;
  tags: string[];
  componentName: string;
  fileName: string;
  versionAdded: string;
  dateAdded: string;
  lastModified: string;
  svgHash: string;
}

export interface IconsExport {
  schemaVersion: string;
  exportedAt: string;
  totalIcons: number;
  icons: Array<{
    name: string;
    tags: string[];
    variants: Array<{
      variant: {
        weight: 'Regular' | 'Bold' | 'Fill';
        duotone: boolean;
      };
      svg: string;
      hash: string;
    }>;
  }>;
}

export interface NameMapping {
  [originalName: string]: string;
}

export interface PathElement {
  d: string;
  opacity?: number;
  fillRule?: 'nonzero' | 'evenodd';
  clipRule?: 'nonzero' | 'evenodd';
}

export type PathData = string | PathElement | PathElement[];

export interface IconPathData {
  regular?: PathData;
  regularDuotone?: PathData;
  bold?: PathData;
  boldDuotone?: PathData;
  fill?: PathData;
  fillDuotone?: PathData;
}
`;

  return typesContent;
}

/**
 * Generate IconBase.d.ts
 */
function generateIconBaseDeclaration() {
  const iconBaseContent = `import { ReactNode } from 'react';
import type { IconProps } from './types';
import type { MemoExoticComponent, ForwardRefExoticComponent, RefAttributes } from 'react';

export interface IconBaseProps extends Omit<IconProps, 'weight' | 'duotone'> {
  children: ReactNode;
}

export declare const IconBase: MemoExoticComponent<ForwardRefExoticComponent<IconBaseProps & RefAttributes<SVGSVGElement>>>;
`;

  return iconBaseContent;
}

/**
 * Generate base.d.ts - separate entry point for IconBase
 */
function generateBaseDeclaration() {
  const baseContent = `// Separate entry point for IconBase (advanced usage)
// Import via: import { IconBase } from 'stera-icons/base';

export { IconBase } from './IconBase';
export type { IconBaseProps } from './IconBase';
`;

  return baseContent;
}

/**
 * Parse src/index.ts and generate index.d.ts
 */
function generateIndexDeclaration() {
  const indexPath = join(SRC_DIR, 'index.ts');
  const indexContent = readFileSync(indexPath, 'utf8');
  
  const lines = indexContent.split('\n');
  const declarationLines = [];
  
  // Add header comment
  declarationLines.push('// Auto-generated TypeScript declarations');
  declarationLines.push('// Generated by scripts/generate-declarations.js');
  declarationLines.push('');
  
  for (const line of lines) {
    const trimmedLine = line.trim();
    
    // Skip empty lines and comments in source, but preserve section comments
    if (trimmedLine === '' || trimmedLine.startsWith('//')) {
      // Preserve section divider comments
      if (trimmedLine.includes('===') || trimmedLine.includes('WRAPPER') || trimmedLine.includes('DIRECT VARIANT')) {
        declarationLines.push(line);
      }
      continue;
    }
    
    // Handle re-exports: export { X } from './path';
    const reExportMatch = trimmedLine.match(/^export\s*\{\s*(\w+)\s*\}\s*from\s*['"]([^'"]+)['"]\s*;?$/);
    if (reExportMatch) {
      const [, exportName, importPath] = reExportMatch;
      declarationLines.push(`export { ${exportName} } from '${importPath}';`);
      continue;
    }
    
    // Handle type re-exports: export type { X } from './path';
    const typeReExportMatch = trimmedLine.match(/^export\s+type\s*\{\s*([^}]+)\s*\}\s*from\s*['"]([^'"]+)['"]\s*;?$/);
    if (typeReExportMatch) {
      const [, typeNames, importPath] = typeReExportMatch;
      declarationLines.push(`export type { ${typeNames} } from '${importPath}';`);
      continue;
    }
  }
  
  return declarationLines.join('\n') + '\n';
}

/**
 * Main function to generate all declarations
 */
function main() {
  console.log('üìù Generating TypeScript declarations...');
  
  // Ensure dist directory exists
  if (!existsSync(DIST_DIR)) {
    mkdirSync(DIST_DIR, { recursive: true });
  }
  
  // Generate types.d.ts
  const typesDeclaration = generateTypesDeclaration();
  writeFileSync(join(DIST_DIR, 'types.d.ts'), typesDeclaration);
  console.log('  ‚úÖ Generated dist/types.d.ts');
  
  // Generate IconBase.d.ts
  const iconBaseDeclaration = generateIconBaseDeclaration();
  writeFileSync(join(DIST_DIR, 'IconBase.d.ts'), iconBaseDeclaration);
  console.log('  ‚úÖ Generated dist/IconBase.d.ts');
  
  // Generate base.d.ts (separate entry point for IconBase)
  const baseDeclaration = generateBaseDeclaration();
  writeFileSync(join(DIST_DIR, 'base.d.ts'), baseDeclaration);
  console.log('  ‚úÖ Generated dist/base.d.ts');
  
  // Generate index.d.ts
  const indexDeclaration = generateIndexDeclaration();
  writeFileSync(join(DIST_DIR, 'index.d.ts'), indexDeclaration);
  
  // Count exports
  const exportCount = (indexDeclaration.match(/^export\s*\{/gm) || []).length;
  const typeExportCount = (indexDeclaration.match(/^export\s+type\s*\{/gm) || []).length;
  console.log(`  ‚úÖ Generated dist/index.d.ts (${exportCount} component exports, ${typeExportCount} type exports)`);
  
  console.log('‚ú® Declaration generation complete!');
}

main();
